<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEXUS ENGINE - V7 WEAPONS UPDATE</title>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #87CEEB; color: white; user-select: none; touch-action: none; }
        canvas { display: block; }
        .hidden { display: none !important; }

        /* UI GERAL */
        #player-list-box { position: absolute; top: 10px; right: 10px; width: 150px; background: rgba(0,0,0,0.6); border: 1px solid #00ff00; padding: 10px; border-radius: 8px; font-size: 11px; z-index: 200; pointer-events: none; }
        #player-list-title { color: #00ff00; border-bottom: 1px solid #444; margin-bottom: 5px; font-weight: bold; text-align: center; }
        .p-item { margin-bottom: 2px; }

        /* MIRA (CROSSHAIR) */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; background: rgba(255, 255, 255, 0.5); border: 1px solid black; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 300; }

        /* ALERTA DE ARMA/PVP */
        #weapon-alert { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); color: red; font-weight: bold; font-size: 16px; text-shadow: 2px 2px 0 #000; display: none; pointer-events: none; }

        /* TECLADO VIRTUAL */
        #keyboard-overlay { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(10,10,10,0.98); border-top: 3px solid #00ff00; display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; padding: 10px; box-sizing: border-box; z-index: 9999; }
        .key { background: #1a1a1a; border: 1px solid #333; color: white; padding: 15px 0; text-align: center; border-radius: 5px; font-weight: bold; cursor: pointer; font-size: 14px; }
        .key:active { background: #00ff00; color: #000; }
        .key.wide { grid-column: span 2; background: #333; }

        /* AUTH E HUB */
        .auth-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(135, 206, 235, 0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 5000; }
        .auth-card { background: #1a1a1a; padding: 25px; border-radius: 15px; border: 2px solid #00ff00; width: 85%; max-width: 320px; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        input { width: 90%; padding: 12px; margin: 10px 0; border-radius: 8px; border: 1px solid #333; background: #222; color: white; text-align: center; font-size: 16px; }
        input[type="color"] { height: 50px; cursor: pointer; padding: 2px; }
        button { width: 100%; padding: 12px; background: #00ff00; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; color: #000; }

        /* MENU LATERAL */
        #server-menu { position: absolute; top: 0; left: -300px; width: 280px; height: 100%; background: rgba(5,5,5,0.95); border-right: 2px solid #00ff00; transition: 0.3s; z-index: 7000; padding: 20px; box-sizing: border-box; }
        #server-menu.open { left: 0; }
        .menu-toggle { position: absolute; top: 20px; right: -55px; width: 50px; height: 50px; background: #000; border: 2px solid #00ff00; color: #00ff00; display: flex; align-items: center; justify-content: center; cursor: pointer; border-radius: 0 10px 10px 0; font-size: 24px; }

        /* CHAT SYSTEM */
        #chat-container { position: absolute; bottom: 120px; left: 20px; width: 300px; height: 200px; z-index: 6000; display: flex; flex-direction: column; pointer-events: none; transition: 0.3s; }
        #chat-toggle-btn { width: fit-content; padding: 2px 10px; background: rgba(0,0,0,0.8); border: 1px solid #00ff00; color: #00ff00; font-size: 10px; cursor: pointer; margin-bottom: 2px; pointer-events: auto; border-radius: 4px 4px 0 0; font-weight: bold; }
        #chat-messages { flex: 1; overflow-y: auto; background: rgba(0,0,0,0.5); border-radius: 0 8px 8px 8px; padding: 10px; margin-bottom: 5px; font-size: 12px; text-shadow: 1px 1px 0 #000; pointer-events: auto; }
        .chat-line { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 2px; }
        .chat-nick { color: #00ff00; font-weight: bold; margin-right: 5px; }
        
        #chat-input-area { display: flex; gap: 5px; pointer-events: auto; }
        #chat-input { flex: 1; background: rgba(0,0,0,0.8); border: 1px solid #333; color: white; padding: 8px; border-radius: 4px; font-size: 12px; }
        #btn-send-chat { background: #00ff00; border: none; padding: 0 15px; border-radius: 4px; font-weight: bold; cursor: pointer; font-size: 12px; }
        #chat-container.minimized { height: 30px; width: auto; }
        #chat-container.minimized #chat-messages, #chat-container.minimized #chat-input-area { display: none !important; }

        /* ADMIN PANEL */
        #admin-panel { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(20,0,0,0.9); border: 2px solid red; padding: 10px; border-radius: 12px; z-index: 8000; display: flex; flex-direction: column; gap: 8px; align-items: center; min-width: 220px; }
        .admin-row { display: flex; gap: 5px; width: 100%; justify-content: center; }
        .admin-btn { background: #440000; color: white; border: 1px solid red; font-size: 10px; padding: 5px; cursor: pointer; border-radius: 4px; flex: 1; }
        .admin-btn:active { background: red; }
        #admin-ban-nick { width: 80%; font-size: 10px; padding: 4px; margin: 0; }

        /* TAGS */
        .player-tag { position: absolute; padding: 2px 8px; background: rgba(0,0,0,0.7); color: #00ff00; border: 1px solid #00ff00; border-radius: 4px; font-size: 11px; pointer-events: none; transform: translate(-50%, -100%); white-space: nowrap; }

        /* GAMEPAD */
        #mobile-controls { position: absolute; bottom: 30px; left: 20px; display: grid; grid-template-columns: repeat(3, 65px); gap: 10px; z-index: 100; }
        .btn-game { width: 65px; height: 65px; background: rgba(0,0,0,0.3); border: 2px solid #00ff00; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #00ff00; font-weight: bold; user-select: none; backdrop-filter: blur(4px); }
        .btn-game:active { background: rgba(0,255,0,0.3); }
    </style>
</head>
<body>

    <div id="login-screen" class="auth-overlay">
        <div class="auth-card">
            <h2 style="color:#00ff00; margin-top:0;">NEXUS ENGINE</h2>
            <input type="email" id="email-field" placeholder="Seu Gmail" readonly onclick="openKeyboard(this)">
            <label style="color:#aaa; font-size:12px; display:block; margin-top:5px;">ESCOLHA A COR DO CUBO</label>
            <input type="color" id="color-picker" value="#00ff00">
            <input type="text" id="user-field" placeholder="Nick do Jogo" readonly onclick="openKeyboard(this)">
            <button onclick="request2FA()">RECEBER C√ìDIGO</button>
            <button onclick="loginAsGuest()" style="margin-top: 10px; background: transparent; border: 1px solid #00ff00; color: #00ff00;">ENTRAR COMO GUEST</button>
        </div>
    </div>

    <div id="2fa-screen" class="auth-overlay hidden">
        <div class="auth-card">
            <h2 style="color:#00ff00">C√ìDIGO 2FA</h2>
            <input type="text" id="2fa-input" placeholder="000000" readonly onclick="openKeyboard(this)">
            <button onclick="verifyAndStart()">ENTRAR</button>
        </div>
    </div>

    <div id="player-list-box" class="hidden">
        <div id="player-list-title">JOGADORES ONLINE</div>
        <div id="player-list-content"></div>
    </div>

    <div id="crosshair" class="hidden"></div>
    <div id="weapon-alert"></div>

    <div id="admin-panel" class="hidden">
        <span style="color:red; font-size:11px; font-weight:bold;">SISTEMA ADM - SUPREME</span>
        <div class="admin-row">
            <button class="admin-btn" onclick="toggleFly()">VOAR: OFF</button>
            <button class="admin-btn" onclick="toggleGiant()">GIGANTE: OFF</button>
        </div>
        <div class="admin-row">
            <button class="admin-btn" onclick="toggleGun()">DAR ARMA</button>
            <button class="admin-btn" onclick="toggleGod()">GOD MODE: OFF</button>
        </div>
        <div class="admin-row">
            <button class="admin-btn" onclick="broadcast({type:'kick-all'})" style="background: red;">KICK ALL</button>
        </div>
        <input type="text" id="admin-ban-nick" placeholder="Nick para Banir" onclick="openKeyboard(this)">
        <div class="admin-row">
            <button class="admin-btn" onclick="adminAction('ban-temp')">BAN TEMP</button>
            <button class="admin-btn" onclick="adminAction('ban-perm')">BAN PERM</button>
        </div>
    </div>

    <div id="server-menu">
        <div class="menu-toggle" onclick="this.parentElement.classList.toggle('open')">‚ò∞</div>
        <h3 style="color:#00ff00; margin-top:0;">üåê MUNDOS P2P</h3>
        <input type="text" id="room-input" placeholder="ID da Sala (ex: sala1)" onclick="openKeyboard(this)">
        <button onclick="startMesh()">CONECTAR AO MUNDO</button>
        <div id="recent-list" style="margin-top:20px;"></div>
    </div>

    <div id="mobile-controls" class="hidden">
        <div style="grid-column: 2" class="btn-game" onpointerdown="keys.w=true" onpointerup="keys.w=false">W</div>
        <div style="grid-column: 1" class="btn-game" onpointerdown="keys.a=true" onpointerup="keys.a=false">A</div>
        <div style="grid-column: 2" class="btn-game" onpointerdown="keys.s=true" onpointerup="keys.s=false">S</div>
        <div style="grid-column: 3" class="btn-game" onpointerdown="keys.d=true" onpointerup="keys.d=false">D</div>
        <div style="grid-column: 2; margin-top:10px; height:45px;" class="btn-game" onpointerdown="jump()">PULAR</div>
    </div>

    <div id="chat-container" class="hidden">
        <div id="chat-toggle-btn" onclick="toggleChatUI()">[-]</div>
        <div id="chat-messages"></div>
        <div id="chat-input-area">
            <input type="text" id="chat-input" placeholder="Mensagem..." onclick="openKeyboard(this)">
            <button id="btn-send-chat" onclick="sendChat()">></button>
        </div>
    </div>

    <div id="keyboard-overlay" class="hidden"></div>

    <script>
        const PREFIX = "NEXUS-MESH-";
        let scene, camera, renderer, playerMesh, controls;
        let peer, connections = {}; 
        let myNick = "", myEmail = "", myCode = "", myID = "";
        let myColor = "#00ff00";
        let remotePlayers = {}; 
        let isHost = false; 
        const keys = { w:false, a:false, s:false, d:false };
        let velocityY = 0, isGrounded = false, moveSpeed = 0.2;
        let collidableObjects = []; 
        let raycaster = new THREE.Raycaster();
        let combatRaycaster = new THREE.Raycaster();
        
        // Armas Visuais
        let mySword, myGun;

        // Atributos Especiais
        let isFlying = false;
        let isGiant = false;
        let isAdmin = false;
        let hasGun = false;
        let isGod = false; 
        let inArena = false; 

        // UI Chat
        function toggleChatUI() {
            const container = document.getElementById('chat-container');
            container.classList.toggle('minimized');
            document.getElementById('chat-toggle-btn').innerText = container.classList.contains('minimized') ? "[CHAT]" : "[-]";
        }

        // Teclado
        let currentInput = null;
        function setupKeyboard() {
            const kb = document.getElementById('keyboard-overlay');
            const chars = "1234567890QWERTYUIOPASDFGHJKL-ZXCVBNM@._ ".split("");
            kb.innerHTML = chars.map(c => `<div class="key" onclick="pressKey('${c}')">${c}</div>`).join("");
            kb.innerHTML += `<div class="key wide" onclick="pressKey('BACK')">‚Üê</div><div class="key wide" onclick="closeKeyboard()" style="background:#00ff00; color:#000;">OK</div>`;
        }
        function openKeyboard(el) { currentInput = el; document.getElementById('keyboard-overlay').classList.remove('hidden'); }
        function pressKey(c) { if(!currentInput) return; if(c==='BACK') currentInput.value = currentInput.value.slice(0,-1); else currentInput.value += c.toLowerCase(); }
        function closeKeyboard() { document.getElementById('keyboard-overlay').classList.add('hidden'); if(currentInput?.id==='chat-input') sendChat(); }

        // Login
        emailjs.init("moDwTMHMA3q3OPbuy");
        
        function checkBan() {
            const permBan = localStorage.getItem('nexus_perm_ban');
            const tempBan = localStorage.getItem('nexus_temp_ban');
            if(permBan) { alert("VOC√ä FOI BANIDO PERMANENTEMENTE."); return true; }
            if(tempBan && Date.now() < parseInt(tempBan)) { alert("VOC√ä EST√Å BANIDO TEMPORARIAMENTE."); return true; }
            return false;
        }

        function request2FA() {
            if(checkBan()) return;
            myEmail = document.getElementById('email-field').value.trim().toLowerCase();
            myNick = document.getElementById('user-field').value.trim() || "User";
            myColor = document.getElementById('color-picker').value;
            myCode = Math.floor(100000 + Math.random() * 900000).toString();
            if(myNick === "dev") { myCode="123456"; alert("DEV: 123456"); }
            else { emailjs.send("default_service", "template_axhickg", { to_email: myEmail, code: myCode, user_nick: myNick }); }
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('2fa-screen').classList.remove('hidden');
        }

        function verifyAndStart() {
            if(document.getElementById('2fa-input').value === myCode) {
                if(myEmail === "luanaaalmeidadesouza@gmail.com") {
                    myNick = "üëë " + myNick;
                    isAdmin = true;
                    document.getElementById('admin-panel').classList.remove('hidden');
                }
                startGameFlow();
            } else alert("C√≥digo Inv√°lido");
        }

        function loginAsGuest() {
            if(checkBan()) return;
            let inputNick = document.getElementById('user-field').value.trim();
            myColor = document.getElementById('color-picker').value;
            myNick = inputNick || "Guest_" + Math.floor(Math.random() * 9999);
            startGameFlow();
        }

        function startGameFlow() {
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('2fa-screen').classList.add('hidden');
            document.getElementById('mobile-controls').classList.remove('hidden');
            document.getElementById('chat-container').classList.remove('hidden');
            document.getElementById('player-list-box').classList.remove('hidden');
            document.getElementById('crosshair').classList.remove('hidden');
            
            initEngine();
            updateRecentUI();
            
            // AUTOMATICAMENTE ENTRA NA ROOM1
            document.getElementById('room-input').value = "room1";
            startMesh();
        }

        // --- FUN√á√ïES ADM ---
        function toggleFly() {
            isFlying = !isFlying;
            document.querySelectorAll('.admin-btn')[0].innerText = `VOAR: ${isFlying ? 'ON' : 'OFF'}`;
            if(!isFlying) velocityY = 0;
        }
        function toggleGiant() {
            isGiant = !isGiant;
            const s = isGiant ? 5 : 1;
            playerMesh.scale.set(s, s, s);
            document.querySelectorAll('.admin-btn')[1].innerText = `GIGANTE: ${isGiant ? 'ON' : 'OFF'}`;
        }
        function toggleGod() {
            isGod = !isGod;
            document.querySelectorAll('.admin-btn')[3].innerText = `GOD MODE: ${isGod ? 'ON' : 'OFF'}`;
        }
        function toggleGun() {
            hasGun = !hasGun;
            updateWeaponStatus();
        }
        function adminAction(type) {
            const target = document.getElementById('admin-ban-nick').value.trim();
            if(!target) return alert("Digite o nick");
            broadcast({ type: 'admin-cmd', cmd: type, target: target });
            addChatMessage("SISTEMA", `COMANDO ${type} ENVIADO PARA: ${target}`);
        }

        // --- SISTEMA DE COMBATE & VISUAL ---
        function updateWeaponStatus() {
            const alertBox = document.getElementById('weapon-alert');
            // Controle de visibilidade das armas locais
            if (mySword && myGun) {
                if(hasGun) {
                    mySword.visible = false;
                    myGun.visible = true;
                } else if(inArena) {
                    mySword.visible = true;
                    myGun.visible = false;
                } else {
                    mySword.visible = false;
                    myGun.visible = false;
                }
            }

            if(hasGun) {
                alertBox.innerText = "ARMA EQUIPADA (ADM)";
                alertBox.style.display = 'block';
            } else if(inArena) {
                alertBox.innerText = "MODO PVP: ESPADA EQUIPADA";
                alertBox.style.display = 'block';
                alertBox.style.color = "orange";
            } else {
                alertBox.style.display = 'none';
            }
        }

        function attemptAttack() {
            if(!hasGun && !inArena) return;

            combatRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const targets = [];
            for(let id in remotePlayers) {
                targets.push(remotePlayers[id].mesh);
            }

            const range = hasGun ? 100 : 5; 
            const intersects = combatRaycaster.intersectObjects(targets);

            if(intersects.length > 0 && intersects[0].distance <= range) {
                const hitMesh = intersects[0].object;
                for(let id in remotePlayers) {
                    if(remotePlayers[id].mesh === hitMesh) {
                        showHitEffect(intersects[0].point);
                        const dmgData = { type: 'damage', targetId: id, damage: 100, shooter: myNick };
                        if(isHost) {
                            const conn = connections[id];
                            if(conn) conn.send(dmgData);
                        } else {
                            broadcast(dmgData); 
                        }
                        addChatMessage("COMBATE", `Voc√™ acertou ${remotePlayers[id].nick}!`);
                        break;
                    }
                }
            } else {
                if(hasGun) showLaser(combatRaycaster.ray);
            }
        }

        function showHitEffect(point) {
            const geo = new THREE.SphereGeometry(0.2, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const sphere = new THREE.Mesh(geo, mat);
            sphere.position.copy(point);
            scene.add(sphere);
            setTimeout(()=> scene.remove(sphere), 500);
        }

        function showLaser(ray) {
            const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const points = [];
            points.push(playerMesh.position.clone().add(new THREE.Vector3(0,0.5,0))); 
            points.push(ray.at(50, new THREE.Vector3())); 
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            setTimeout(() => scene.remove(line), 100);
        }

        function dieAndRespawn() {
            if(isGod) return; 
            playerMesh.position.set(0, 10, 0); 
            velocityY = 0;
            addChatMessage("COMBATE", "VOC√ä MORREU!");
        }

        // --- NETWORKING ---
        function startMesh() {
            let room = document.getElementById('room-input').value.trim().toLowerCase();
            if(!room) return;
            const fullRoomID = room.startsWith(PREFIX) ? room : PREFIX + room;
            document.getElementById('server-menu').classList.remove('open');
            saveRecent(room);
            tryToBecomeHost(fullRoomID, room);
        }

        function tryToBecomeHost(id, roomNameDisplay) {
            peer = new Peer(id);
            peer.on('open', (myPeerId) => {
                myID = myPeerId; isHost = true;
                updatePlayerList();
            });
            peer.on('error', (err) => {
                if(err.type === 'unavailable-id') { peer.destroy(); becomeClient(id, roomNameDisplay); }
            });
            peer.on('connection', setupConn);
        }

        function becomeClient(hostId, roomNameDisplay) {
            myID = hostId + "-player-" + Math.floor(Math.random()*9999);
            peer = new Peer(myID);
            peer.on('open', () => {
                isHost = false;
                setupConn(peer.connect(hostId));
            });
            peer.on('connection', setupConn); 
        }

        function setupConn(conn) {
            conn.on('open', () => {
                connections[conn.peer] = conn;
                // Envia pacote inicial
                conn.send({ type: 'hello', nick: myNick, x: 0, y: 0.5, z: 0, senderId: myID, scale: isGiant?5:1, color: myColor });
                updatePlayerList();
            });
            conn.on('data', data => handleData(data, conn.peer));
            conn.on('close', () => { removePlayer(conn.peer); updatePlayerList(); });
        }

        function handleData(data, senderPeerId) {
            if(isHost) {
                data.senderId = data.senderId || senderPeerId; 
                broadcast(data, senderPeerId);
            }
            if(data.type === 'damage') {
                if(data.targetId === myID || (isHost && data.targetId === peer.id)) {
                    dieAndRespawn();
                }
            }

            if(data.senderId === myID) return;

            if(data.type === 'hello' || data.type === 'move') {
                updateRemote(data.senderId, data);
                if(data.type === 'hello') updatePlayerList();
            }
            if(data.type === 'chat') addChatMessage(data.nick, data.text);
            if(data.type === 'kick-all') location.reload();
            if(data.type === 'admin-cmd') {
                const me = myNick.replace("üëë ", "");
                if(data.target === me) {
                    if(data.cmd === 'ban-temp') { localStorage.setItem('nexus_temp_ban', Date.now() + (300000)); location.reload(); }
                    if(data.cmd === 'ban-perm') { localStorage.setItem('nexus_perm_ban', 'true'); location.reload(); }
                }
            }
        }

        function broadcast(data, ignoreId) {
            for(let id in connections) {
                if(connections[id].open && id !== ignoreId) connections[id].send(data);
            }
        }

        function updatePlayerList() {
            const listEl = document.getElementById('player-list-content');
            let html = `<div class="p-item" style="color:#00ff00">> ${myNick} (Voc√™)</div>`;
            for(let id in remotePlayers) {
                html += `<div class="p-item">> ${remotePlayers[id].nick}</div>`;
            }
            listEl.innerHTML = html;
        }

        function sendChat() {
            const input = document.getElementById('chat-input');
            if(!input.value.trim()) return;
            const msg = { type: 'chat', text: input.value, nick: myNick, senderId: myID };
            addChatMessage(myNick, input.value);
            if (isHost) broadcast(msg, null);
            else for(let id in connections) connections[id].send(msg);
            input.value = "";
        }

        function addChatMessage(nick, text) {
            const box = document.getElementById('chat-messages');
            const div = document.createElement('div');
            div.className = 'chat-line';
            div.innerHTML = `<span class="chat-nick">${nick}:</span><span>${text}</span>`;
            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
        }

        function createSign(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color || '#aa0000';
            ctx.fillRect(0,0,512,128);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 64);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: tex });
            return new THREE.Mesh(new THREE.PlaneGeometry(10, 2.5), mat);
        }

        // Helper para criar armas
        function createWeaponMesh(type) {
            const group = new THREE.Group();
            if(type === 'sword') {
                // Cabo
                const handle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.1), new THREE.MeshLambertMaterial({color:0x8B4513}));
                // L√¢mina
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.2, 0.05), new THREE.MeshStandardMaterial({color:0xcccccc, metalness:0.8, roughness:0.2}));
                blade.position.y = 0.8;
                // Guarda
                const guard = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.05, 0.1), new THREE.MeshLambertMaterial({color:0xFFD700}));
                guard.position.y = 0.2;
                
                group.add(handle, blade, guard);
                // Posicionar na "m√£o" (lado direito do cubo)
                group.rotation.x = Math.PI / 2; // Apontar pra frente
                group.position.set(0.6, 0, -0.4);
            } else if (type === 'gun') {
                // Corpo da arma
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.6), new THREE.MeshLambertMaterial({color:0x111111}));
                // Cano
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6), new THREE.MeshLambertMaterial({color:0x333333}));
                barrel.rotation.x = Math.PI / 2;
                barrel.position.z = -0.3;
                barrel.position.y = 0.05;
                // Cabo
                const handle = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), new THREE.MeshLambertMaterial({color:0x000000}));
                handle.position.y = -0.2;
                handle.rotation.x = 0.5;

                group.add(body, barrel, handle);
                group.position.set(0.6, 0, -0.4);
            }
            return group;
        }

        function initEngine() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            renderer.domElement.addEventListener('pointerdown', (e) => {
                if(e.target.className.includes('btn-game')) return;
                attemptAttack();
            });

            document.body.appendChild(renderer.domElement);
            
            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 0.8 );
            hemiLight.position.set( 0, 20, 0 );
            scene.add( hemiLight );
            const dirLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
            dirLight.position.set( -10, 20, 10 );
            dirLight.castShadow = true;
            scene.add( dirLight );

            // CH√ÉO
            const planeGeo = new THREE.PlaneGeometry(100, 100);
            const planeMat = new THREE.MeshStandardMaterial({ color: 0x228B22 }); 
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);
            scene.add(new THREE.GridHelper(100, 50, 0x000000, 0x004400));
            collidableObjects.push(plane);

            // PAREDES
            const wallMat = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.1, transparent: true, side: THREE.DoubleSide });
            const w1 = new THREE.Mesh(new THREE.BoxGeometry(100, 50, 1), wallMat); w1.position.set(0, 25, -50); scene.add(w1);
            const w2 = new THREE.Mesh(new THREE.BoxGeometry(100, 50, 1), wallMat); w2.position.set(0, 25, 50); scene.add(w2);
            const w3 = new THREE.Mesh(new THREE.BoxGeometry(1, 50, 100), wallMat); w3.position.set(50, 25, 0); scene.add(w3);
            const w4 = new THREE.Mesh(new THREE.BoxGeometry(1, 50, 100), wallMat); w4.position.set(-50, 25, 0); scene.add(w4);
            collidableObjects.push(w1, w2, w3, w4);

            // --- ARENA DE LUTA (MENOR AGORA) ---
            // Tamanho alterado de 30 para 12
            const arenaGeo = new THREE.BoxGeometry(12, 1, 12);
            const arenaMat = new THREE.MeshStandardMaterial({ color: 0xaa0000 }); 
            const arena = new THREE.Mesh(arenaGeo, arenaMat);
            arena.position.set(-40, 5, 0); 
            arena.receiveShadow = true;
            scene.add(arena);
            collidableObjects.push(arena);
            
            const signArena = createSign("ARENA PVP", "#000");
            signArena.position.set(-40, 10, 0);
            scene.add(signArena);

            // --- PARKOUR ---
            const boxGeo = new THREE.BoxGeometry(2, 0.5, 2);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            for(let i=0; i<10; i++) {
                const p = new THREE.Mesh(boxGeo, boxMat);
                p.position.set(10 + (i*3), 2 + (i*1.5), -10 + (Math.random()*5));
                scene.add(p);
                collidableObjects.push(p);
            }

            // --- ESCADA ---
            const stepGeo = new THREE.BoxGeometry(3, 0.5, 1);
            const stepMat = new THREE.MeshStandardMaterial({ color: 0xFF00FF });
            for(let i=0; i<80; i++) {
                const step = new THREE.Mesh(stepGeo, stepMat);
                const angle = i * 0.3; 
                const radius = 8;
                step.position.set(Math.cos(angle) * radius + 20, 1 + (i * 0.8), Math.sin(angle) * radius + 20);
                step.rotation.y = -angle;
                scene.add(step);
                collidableObjects.push(step);
            }

            // PLAYER & WEAPONS
            playerMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshPhongMaterial({ color: myColor }));
            playerMesh.position.y = 0.5;
            playerMesh.castShadow = true;
            
            // Adicionar armas ao player
            mySword = createWeaponMesh('sword');
            myGun = createWeaponMesh('gun');
            mySword.visible = false;
            myGun.visible = false;
            playerMesh.add(mySword);
            playerMesh.add(myGun);

            scene.add(playerMesh);

            // C√ÇMERA
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = false;
            controls.minDistance = 3;
            controls.maxDistance = 20;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; 
            
            animate();
        }

        function jump() { 
            if(isFlying) { velocityY = 0.5; return; }
            if(isGrounded) { velocityY = 0.35; isGrounded = false; } 
        }

        function checkCollisions() {
            if(playerMesh.position.x > 49) playerMesh.position.x = 49;
            if(playerMesh.position.x < -49) playerMesh.position.x = -49;
            if(playerMesh.position.z > 49) playerMesh.position.z = 49;
            if(playerMesh.position.z < -49) playerMesh.position.z = -49;

            raycaster.set(playerMesh.position, new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObjects(collidableObjects);
            
            if (intersects.length > 0 && intersects[0].distance < 0.6 + velocityY) {
                 if(velocityY <= 0) {
                     isGrounded = true;
                     velocityY = 0;
                     playerMesh.position.y = intersects[0].point.y + 0.5;
                 }
            } else {
                isGrounded = false;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!playerMesh) return;

            let moved = false;
            let forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0; 
            forward.normalize();
            let right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize(); 

            if(keys.w) { playerMesh.position.add(forward.multiplyScalar(moveSpeed)); moved = true; }
            if(keys.s) { playerMesh.position.add(forward.multiplyScalar(-moveSpeed)); moved = true; }
            if(keys.a) { playerMesh.position.add(right.multiplyScalar(-moveSpeed)); moved = true; } 
            if(keys.d) { playerMesh.position.add(right.multiplyScalar(moveSpeed)); moved = true; } 

            if(!isFlying) {
                velocityY -= 0.015; 
                playerMesh.position.y += velocityY;
                checkCollisions(); 
                if(playerMesh.position.y < -20) dieAndRespawn();
            } else {
                playerMesh.position.y += velocityY;
                velocityY *= 0.9; 
            }

            controls.target.copy(playerMesh.position);
            controls.update();

            // L√≥gica Arena Atualizada para Tamanho Menor (Centro -40, Raio aprox 6)
            if(playerMesh.position.x > -46 && playerMesh.position.x < -34 && 
               playerMesh.position.z > -6 && playerMesh.position.z < 6 && 
               playerMesh.position.y > 4) {
                   if(!inArena) { inArena = true; updateWeaponStatus(); }
               } else {
                   if(inArena) { inArena = false; updateWeaponStatus(); }
               }

            if(moved || !isGrounded || isFlying || inArena || hasGun) {
                // Enviar estado da arma no pacote de movimento
                // wp: 0 = nada, 1 = espada, 2 = arma
                const wpState = hasGun ? 2 : (inArena ? 1 : 0);
                
                const moveData = { 
                    type:'move', 
                    x:playerMesh.position.x, 
                    y:playerMesh.position.y, 
                    z:playerMesh.position.z, 
                    nick: myNick, 
                    senderId: myID,
                    scale: isGiant ? 5 : 1,
                    color: myColor,
                    wp: wpState 
                };
                if(isHost) broadcast(moveData, null); 
                else for(let id in connections) connections[id].send(moveData);
            }

            // Tags e Interpola√ß√£o
            for(let id in remotePlayers) {
                const p = remotePlayers[id];
                p.mesh.position.lerp(p.targetPos, 0.2);
                const tagOffset = p.mesh.scale.x * 1.2;
                const tempV = p.mesh.position.clone().add(new THREE.Vector3(0, tagOffset, 0)).project(camera);
                if(tempV.z < 1) {
                     p.tag.style.left = (tempV.x * .5 + .5) * window.innerWidth + 'px';
                     p.tag.style.top = (tempV.y * -.5 + .5) * window.innerHeight + 'px';
                     p.tag.style.display = 'block';
                } else { p.tag.style.display = 'none'; }
            }
            renderer.render(scene, camera);
        }

        function updateRemote(id, data) {
            if(!remotePlayers[id]) {
                const pColor = data.color || 0x00ffff;
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshPhongMaterial({ color: pColor }));
                
                // Adicionar armas visuais ao remote player
                const rSword = createWeaponMesh('sword');
                const rGun = createWeaponMesh('gun');
                rSword.visible = false;
                rGun.visible = false;
                mesh.add(rSword);
                mesh.add(rGun);
                
                mesh.castShadow = true;
                scene.add(mesh);
                const tag = document.createElement('div');
                tag.className = 'player-tag';
                tag.innerText = data.nick || "Player";
                document.body.appendChild(tag);
                
                remotePlayers[id] = { 
                    mesh, tag, 
                    targetPos: new THREE.Vector3(data.x, data.y, data.z), 
                    nick: data.nick,
                    sword: rSword,
                    gun: rGun 
                };
            } else {
                remotePlayers[id].targetPos.set(data.x, data.y, data.z);
                if(data.scale) remotePlayers[id].mesh.scale.set(data.scale, data.scale, data.scale);
                
                // Atualizar arma do remote player baseado no pacote 'wp'
                const p = remotePlayers[id];
                if(data.wp === 2) { p.sword.visible=false; p.gun.visible=true; }
                else if(data.wp === 1) { p.sword.visible=true; p.gun.visible=false; }
                else { p.sword.visible=false; p.gun.visible=false; }
            }
        }

        function removePlayer(id) {
            if(remotePlayers[id]) {
                scene.remove(remotePlayers[id].mesh);
                if(remotePlayers[id].tag) document.body.removeChild(remotePlayers[id].tag);
                delete remotePlayers[id];
                delete connections[id];
            }
        }

        function saveRecent(id) {
            let r = JSON.parse(localStorage.getItem('n_rooms') || "[]");
            if(!r.includes(id)) r.push(id);
            localStorage.setItem('n_rooms', JSON.stringify(r.slice(-5)));
            updateRecentUI();
        }

        function updateRecentUI() {
            const list = JSON.parse(localStorage.getItem('n_rooms') || "[]");
            document.getElementById('recent-list').innerHTML = list.map(id => `<div style="background:#222; padding:8px; margin-top:5px; font-size:10px; border:1px solid #333; cursor:pointer;" onclick="document.getElementById('room-input').value='${id}'; startMesh()">${id}</div>`).join('');
        }

        setupKeyboard();
    </script>
</body>
</html>
