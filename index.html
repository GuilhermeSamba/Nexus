<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEXUS ENGINE - V8.1 PHYSICS FIX</title>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #87CEEB; color: white; user-select: none; touch-action: none; }
        canvas { display: block; }
        .hidden { display: none !important; }

        /* UI GERAL */
        #player-list-box { position: absolute; top: 10px; right: 10px; width: 150px; background: rgba(0,0,0,0.6); border: 1px solid #00ff00; padding: 10px; border-radius: 8px; font-size: 11px; z-index: 200; pointer-events: none; }
        #player-list-title { color: #00ff00; border-bottom: 1px solid #444; margin-bottom: 5px; font-weight: bold; text-align: center; }
        .p-item { margin-bottom: 2px; }

        /* MIRA */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; background: rgba(255, 255, 255, 0.5); border: 1px solid black; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 300; }

        /* ALERTA */
        #weapon-alert { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); color: red; font-weight: bold; font-size: 16px; text-shadow: 2px 2px 0 #000; display: none; pointer-events: none; }

        /* TECLADO VIRTUAL CUSTOMIZADO */
        #keyboard-overlay { 
            position: absolute; 
            bottom: 0; 
            left: 0; 
            width: 100%; 
            background: rgba(15,15,15,0.98); 
            border-top: 3px solid #00ff00; 
            display: grid; 
            grid-template-columns: repeat(10, 1fr); 
            gap: 4px; 
            padding: 8px; 
            box-sizing: border-box; 
            z-index: 10000; 
            box-shadow: 0 -5px 15px rgba(0,0,0,0.5);
        }
        .key { 
            background: #252525; 
            border: 1px solid #444; 
            color: white; 
            padding: 12px 0; 
            text-align: center; 
            border-radius: 6px; 
            font-weight: bold; 
            cursor: pointer; 
            font-size: 16px; 
            text-transform: uppercase;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.1s;
        }
        .key:active { background: #00ff00; color: #000; transform: scale(0.95); }
        .key.wide { grid-column: span 2; background: #333; }
        .key.space { grid-column: span 4; }
        .key.ok { background: #00ff00; color: #000; grid-column: span 2; }

        /* AUTH E HUB */
        .auth-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(135, 206, 235, 0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 5000; }
        .auth-card { background: #1a1a1a; padding: 25px; border-radius: 15px; border: 2px solid #00ff00; width: 85%; max-width: 320px; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        input, select { width: 90%; padding: 12px; margin: 10px 0; border-radius: 8px; border: 1px solid #333; background: #222; color: white; text-align: center; font-size: 16px; }
        input[type="color"] { height: 50px; cursor: pointer; padding: 2px; }
        button { width: 100%; padding: 12px; background: #00ff00; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; color: #000; margin-top: 5px; }

        /* MENU LATERAL */
        #server-menu { position: absolute; top: 0; left: -300px; width: 280px; height: 100%; background: rgba(5,5,5,0.95); border-right: 2px solid #00ff00; transition: 0.3s; z-index: 7000; padding: 20px; box-sizing: border-box; }
        #server-menu.open { left: 0; }
        .menu-toggle { position: absolute; top: 20px; right: -55px; width: 50px; height: 50px; background: #000; border: 2px solid #00ff00; color: #00ff00; display: flex; align-items: center; justify-content: center; cursor: pointer; border-radius: 0 10px 10px 0; font-size: 24px; }

        /* CHAT */
        #chat-container { position: absolute; bottom: 120px; left: 20px; width: 300px; height: 200px; z-index: 6000; display: flex; flex-direction: column; pointer-events: none; transition: 0.3s; }
        #chat-toggle-btn { width: fit-content; padding: 2px 10px; background: rgba(0,0,0,0.8); border: 1px solid #00ff00; color: #00ff00; font-size: 10px; cursor: pointer; margin-bottom: 2px; pointer-events: auto; border-radius: 4px 4px 0 0; font-weight: bold; }
        #chat-messages { flex: 1; overflow-y: auto; background: rgba(0,0,0,0.5); border-radius: 0 8px 8px 8px; padding: 10px; margin-bottom: 5px; font-size: 12px; text-shadow: 1px 1px 0 #000; pointer-events: auto; }
        .chat-line { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 2px; }
        .chat-nick { color: #00ff00; font-weight: bold; margin-right: 5px; }
        #chat-input-area { display: flex; gap: 5px; pointer-events: auto; }
        #chat-input { flex: 1; background: rgba(0,0,0,0.8); border: 1px solid #333; color: white; padding: 8px; border-radius: 4px; font-size: 12px; }
        #btn-send-chat { background: #00ff00; border: none; padding: 0 15px; border-radius: 4px; font-weight: bold; cursor: pointer; font-size: 12px; }
        #chat-container.minimized { height: 30px; width: auto; }
        #chat-container.minimized #chat-messages, #chat-container.minimized #chat-input-area { display: none !important; }

        /* ADMIN */
        #admin-panel { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(20,0,0,0.9); border: 2px solid red; padding: 10px; border-radius: 12px; z-index: 8000; display: flex; flex-direction: column; gap: 8px; align-items: center; min-width: 220px; }
        .admin-row { display: flex; gap: 5px; width: 100%; justify-content: center; }
        .admin-btn { background: #440000; color: white; border: 1px solid red; font-size: 10px; padding: 5px; cursor: pointer; border-radius: 4px; flex: 1; }
        .admin-btn:active { background: red; }
        #admin-ban-nick { width: 80%; font-size: 10px; padding: 4px; margin: 0; }

        /* TAGS */
        .player-tag { position: absolute; padding: 2px 8px; background: rgba(0,0,0,0.7); color: #00ff00; border: 1px solid #00ff00; border-radius: 4px; font-size: 11px; pointer-events: none; transform: translate(-50%, -100%); white-space: nowrap; }

        /* MOBILE CONTROLS */
        #mobile-controls { position: absolute; bottom: 30px; left: 20px; display: grid; grid-template-columns: repeat(3, 65px); gap: 10px; z-index: 100; }
        .btn-game { width: 65px; height: 65px; background: rgba(0,0,0,0.3); border: 2px solid #00ff00; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #00ff00; font-weight: bold; user-select: none; backdrop-filter: blur(4px); }
        .btn-game:active { background: rgba(0,255,0,0.3); }

        #logout-btn { background: red; color: white; border: 1px solid #fff; margin-top: 20px; }
    </style>
</head>
<body>

    <div id="login-screen" class="auth-overlay">
        <div class="auth-card">
            <h2 style="color:#00ff00; margin-top:0;">NEXUS HUMAN</h2>
            <input type="email" id="email-field" placeholder="Seu Gmail" readonly onclick="openKeyboard(this)">
            <label style="color:#aaa; font-size:12px; display:block; margin-top:5px;">COR DO CORPO</label>
            <input type="color" id="color-picker" value="#00ff00">
            <label style="color:#aaa; font-size:12px; display:block; margin-top:5px;">ROUPA / SKIN</label>
            <select id="skin-select" style="background:#222; color:white;">
                <option value="casual">Casual (Preto)</option>
                <option value="suit">Terno (Azul Escuro)</option>
                <option value="military">Militar (Verde Oliva)</option>
                <option value="neon">Neon Cyber</option>
            </select>
            <input type="text" id="user-field" placeholder="Nick do Jogo" readonly onclick="openKeyboard(this)">
            <button onclick="request2FA()">RECEBER C√ìDIGO</button>
            <button onclick="loginAsGuest()" style="background: transparent; border: 1px solid #00ff00; color: #00ff00;">ENTRAR COMO GUEST</button>
        </div>
    </div>

    <div id="2fa-screen" class="auth-overlay hidden">
        <div class="auth-card">
            <h2 style="color:#00ff00">C√ìDIGO 2FA</h2>
            <input type="text" id="2fa-input" placeholder="000000" readonly onclick="openKeyboard(this)">
            <button onclick="verifyAndStart()">ENTRAR</button>
        </div>
    </div>

    <div id="player-list-box" class="hidden">
        <div id="player-list-title">JOGADORES ONLINE</div>
        <div id="player-list-content"></div>
    </div>

    <div id="crosshair" class="hidden"></div>
    <div id="weapon-alert"></div>

    <div id="admin-panel" class="hidden">
        <span style="color:red; font-size:11px; font-weight:bold;">SISTEMA ADM - SUPREME</span>
        <div class="admin-row">
            <button class="admin-btn" onclick="toggleFly()">VOAR: OFF</button>
            <button class="admin-btn" onclick="toggleGiant()">GIGANTE: OFF</button>
        </div>
        <div class="admin-row">
            <button class="admin-btn" onclick="toggleGun()">DAR ARMA</button>
            <button class="admin-btn" onclick="toggleGod()">GOD MODE: OFF</button>
        </div>
        <div class="admin-row">
            <button class="admin-btn" onclick="broadcast({type:'kick-all'})" style="background: red;">KICK ALL</button>
        </div>
        <input type="text" id="admin-ban-nick" placeholder="Nick para Banir" onclick="openKeyboard(this)">
        <div class="admin-row">
            <button class="admin-btn" onclick="adminAction('ban-temp')">BAN TEMP</button>
            <button class="admin-btn" onclick="adminAction('ban-perm')">BAN PERM</button>
        </div>
    </div>

    <div id="server-menu">
        <div class="menu-toggle" onclick="this.parentElement.classList.toggle('open')">‚ò∞</div>
        <h3 style="color:#00ff00; margin-top:0;">üåê MUNDOS P2P</h3>
        <input type="text" id="room-input" placeholder="ID da Sala (ex: sala1)" onclick="openKeyboard(this)">
        <button onclick="startMesh()">CONECTAR AO MUNDO</button>
        <button id="logout-btn" onclick="doLogout()">SAIR (LOGOUT)</button>
        <div id="recent-list" style="margin-top:20px;"></div>
    </div>

    <div id="mobile-controls" class="hidden">
        <div style="grid-column: 2" class="btn-game" onpointerdown="keys.w=true" onpointerup="keys.w=false">W</div>
        <div style="grid-column: 1" class="btn-game" onpointerdown="keys.a=true" onpointerup="keys.a=false">A</div>
        <div style="grid-column: 2" class="btn-game" onpointerdown="keys.s=true" onpointerup="keys.s=false">S</div>
        <div style="grid-column: 3" class="btn-game" onpointerdown="keys.d=true" onpointerup="keys.d=false">D</div>
        <div style="grid-column: 2; margin-top:10px; height:45px;" class="btn-game" onpointerdown="jump()">PULAR</div>
    </div>

    <div id="chat-container" class="hidden">
        <div id="chat-toggle-btn" onclick="toggleChatUI()">[-]</div>
        <div id="chat-messages"></div>
        <div id="chat-input-area">
            <input type="text" id="chat-input" placeholder="Mensagem..." onclick="openKeyboard(this)">
            <button id="btn-send-chat" onclick="sendChat()">></button>
        </div>
    </div>

    <div id="keyboard-overlay" class="hidden"></div>

    <script>
        const PREFIX = "NEXUS-MESH-";
        let scene, camera, renderer, playerMesh, controls;
        let peer, connections = {}; 
        let myNick = "", myEmail = "", myCode = "", myID = "";
        let myColor = "#00ff00";
        let mySkin = "casual"; 
        let remotePlayers = {}; 
        let isHost = false; 
        const keys = { w:false, a:false, s:false, d:false };
        let velocityY = 0, isGrounded = false, moveSpeed = 0.2;
        let collidableObjects = []; 
        let raycaster = new THREE.Raycaster();
        let combatRaycaster = new THREE.Raycaster();
        
        let playerLimbs = { leftArm: null, rightArm: null, leftLeg: null, rightLeg: null };

        let mySword, myGun;

        let isFlying = false;
        let isGiant = false;
        let isAdmin = false;
        let hasGun = false;
        let isGod = false; 
        let inArena = false; 

        // UI Chat
        function toggleChatUI() {
            const container = document.getElementById('chat-container');
            container.classList.toggle('minimized');
            document.getElementById('chat-toggle-btn').innerText = container.classList.contains('minimized') ? "[CHAT]" : "[-]";
        }

        // --- SISTEMA DE TECLADO VIRTUAL MELHORADO ---
        let currentInput = null;
        function setupKeyboard() {
            const kb = document.getElementById('keyboard-overlay');
            const rows = [
                "1234567890",
                "QWERTYUIOP",
                "ASDFGHJKL",
                "ZXCVBNM@._"
            ];
            
            let html = "";
            rows.forEach(row => {
                html += row.split("").map(c => `<div class="key" onclick="pressKey('${c}')">${c}</div>`).join("");
            });

            // Teclas de controle
            html += `<div class="key wide" onclick="pressKey('BACK')">BACK</div>`;
            html += `<div class="key space" onclick="pressKey(' ')">ESPA√áO</div>`;
            html += `<div class="key ok" onclick="closeKeyboard()">OK</div>`;
            
            kb.innerHTML = html;
        }

        function openKeyboard(el) { 
            currentInput = el; 
            document.getElementById('keyboard-overlay').classList.remove('hidden'); 
            // Faz scroll autom√°tico para o input n√£o ficar atr√°s do teclado se necess√°rio
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function pressKey(c) { 
            if(!currentInput) return; 
            if(c === 'BACK') {
                currentInput.value = currentInput.value.slice(0, -1);
            } else {
                // Mant√©m min√∫sculo se for email, sen√£o normal
                let val = (currentInput.type === 'email') ? c.toLowerCase() : c;
                currentInput.value += val;
            }
        }

        function closeKeyboard() { 
            document.getElementById('keyboard-overlay').classList.add('hidden'); 
            if(currentInput?.id === 'chat-input' && currentInput.value.trim() !== "") {
                sendChat();
            }
            currentInput = null;
        }
        // --------------------------------------------

        // Login System
        emailjs.init("moDwTMHMA3q3OPbuy");

        window.onload = function() {
            const savedData = localStorage.getItem('nexus_auth_v2');
            if(savedData) {
                const data = JSON.parse(savedData);
                myEmail = data.email;
                myNick = data.nick;
                myColor = data.color;
                mySkin = data.skin || "casual";
                
                document.getElementById('email-field').value = myEmail;
                document.getElementById('user-field').value = myNick;
                document.getElementById('color-picker').value = myColor;
                document.getElementById('skin-select').value = mySkin;

                if(myEmail === "luanaaalmeidadesouza@gmail.com") {
                    myNick = "üëë " + myNick;
                    isAdmin = true;
                    document.getElementById('admin-panel').classList.remove('hidden');
                }
                startGameFlow();
            }
        };

        function doLogout() {
            localStorage.removeItem('nexus_auth_v2');
            location.reload();
        }
        
        function checkBan() {
            const permBan = localStorage.getItem('nexus_perm_ban');
            const tempBan = localStorage.getItem('nexus_temp_ban');
            if(permBan) { alert("VOC√ä FOI BANIDO PERMANENTEMENTE."); return true; }
            if(tempBan && Date.now() < parseInt(tempBan)) { alert("VOC√ä EST√Å BANIDO TEMPORARIAMENTE."); return true; }
            return false;
        }

        function request2FA() {
            if(checkBan()) return;
            myEmail = document.getElementById('email-field').value.trim().toLowerCase();
            myNick = document.getElementById('user-field').value.trim() || "User";
            myColor = document.getElementById('color-picker').value;
            mySkin = document.getElementById('skin-select').value;

            myCode = Math.floor(100000 + Math.random() * 900000).toString();
            if(myNick === "dev") { myCode="123456"; alert("DEV: 123456"); }
            else { emailjs.send("default_service", "template_axhickg", { to_email: myEmail, code: myCode, user_nick: myNick }); }
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('2fa-screen').classList.remove('hidden');
        }

        function verifyAndStart() {
            if(document.getElementById('2fa-input').value === myCode) {
                localStorage.setItem('nexus_auth_v2', JSON.stringify({
                    email: myEmail, nick: myNick, color: myColor, skin: mySkin
                }));

                if(myEmail === "luanaaalmeidadesouza@gmail.com") {
                    myNick = "üëë " + myNick;
                    isAdmin = true;
                    document.getElementById('admin-panel').classList.remove('hidden');
                }
                startGameFlow();
            } else alert("C√≥digo Inv√°lido");
        }

        function loginAsGuest() {
            if(checkBan()) return;
            let inputNick = document.getElementById('user-field').value.trim();
            myColor = document.getElementById('color-picker').value;
            mySkin = document.getElementById('skin-select').value;
            myNick = inputNick || "Guest_" + Math.floor(Math.random() * 9999);
            startGameFlow();
        }

        function startGameFlow() {
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('2fa-screen').classList.add('hidden');
            document.getElementById('mobile-controls').classList.remove('hidden');
            document.getElementById('chat-container').classList.remove('hidden');
            document.getElementById('player-list-box').classList.remove('hidden');
            document.getElementById('crosshair').classList.remove('hidden');
            
            initEngine();
            updateRecentUI();
            
            document.getElementById('room-input').value = "room1";
            startMesh();
        }

        // --- FUN√á√ïES ADM ---
        function toggleFly() {
            isFlying = !isFlying;
            document.querySelectorAll('.admin-btn')[0].innerText = `VOAR: ${isFlying ? 'ON' : 'OFF'}`;
            if(!isFlying) velocityY = 0;
        }
        function toggleGiant() {
            isGiant = !isGiant;
            const s = isGiant ? 5 : 1;
            playerMesh.scale.set(s, s, s);
            document.querySelectorAll('.admin-btn')[1].innerText = `GIGANTE: ${isGiant ? 'ON' : 'OFF'}`;
        }
        function toggleGod() {
            isGod = !isGod;
            document.querySelectorAll('.admin-btn')[3].innerText = `GOD MODE: ${isGod ? 'ON' : 'OFF'}`;
        }
        function toggleGun() {
            hasGun = !hasGun;
            updateWeaponStatus();
        }
        function adminAction(type) {
            const target = document.getElementById('admin-ban-nick').value.trim();
            if(!target) return alert("Digite o nick");
            broadcast({ type: 'admin-cmd', cmd: type, target: target });
            addChatMessage("SISTEMA", `COMANDO ${type} ENVIADO PARA: ${target}`);
        }

        // --- SISTEMA DE COMBATE & VISUAL ---
        function updateWeaponStatus() {
            const alertBox = document.getElementById('weapon-alert');
            if (mySword && myGun) {
                if(hasGun) {
                    mySword.visible = false;
                    myGun.visible = true;
                } else if(inArena) {
                    mySword.visible = true;
                    myGun.visible = false;
                } else {
                    mySword.visible = false;
                    myGun.visible = false;
                }
            }

            if(hasGun) {
                alertBox.innerText = "ARMA EQUIPADA (ADM) - LETAL";
                alertBox.style.display = 'block';
                alertBox.style.color = "red";
            } else if(inArena) {
                alertBox.innerText = "MODO PVP: ESPADA EQUIPADA";
                alertBox.style.display = 'block';
                alertBox.style.color = "orange";
            } else {
                alertBox.style.display = 'none';
            }
        }

        function attemptAttack() {
            if(!hasGun && !inArena) return;

            combatRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const targets = [];
            for(let id in remotePlayers) {
                targets.push(remotePlayers[id].mesh);
            }

            const range = hasGun ? 200 : 5; 
            const intersects = combatRaycaster.intersectObjects(targets, true);

            if(intersects.length > 0 && intersects[0].distance <= range) {
                let hitObj = intersects[0].object;
                while(hitObj.parent && hitObj.parent.type !== "Scene") {
                    hitObj = hitObj.parent;
                }

                for(let id in remotePlayers) {
                    if(remotePlayers[id].mesh === hitObj) {
                        showHitEffect(intersects[0].point);
                        const dmgData = { type: 'damage', targetId: id, damage: 100, shooter: myNick };
                        
                        if(hasGun) {
                            if(isHost) {
                                const conn = connections[id];
                                if(conn) conn.send(dmgData);
                            } else {
                                broadcast(dmgData); 
                            }
                            addChatMessage("COMBATE", `TIRO LASER EM ${remotePlayers[id].nick}!`);
                        } else {
                            if(isHost) {
                                const conn = connections[id];
                                if(conn) conn.send(dmgData);
                            } else {
                                broadcast(dmgData); 
                            }
                            addChatMessage("COMBATE", `Espadada em ${remotePlayers[id].nick}!`);
                        }
                        break;
                    }
                }
            } 
            
            if(hasGun) showLaser(combatRaycaster.ray);
        }

        function showHitEffect(point) {
            const geo = new THREE.SphereGeometry(0.2, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const sphere = new THREE.Mesh(geo, mat);
            sphere.position.copy(point);
            scene.add(sphere);
            setTimeout(()=> scene.remove(sphere), 500);
        }

        function showLaser(ray) {
            const material = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
            const points = [];
            const startPos = playerMesh.position.clone().add(new THREE.Vector3(0.5, 0.5, 0).applyQuaternion(playerMesh.quaternion));
            points.push(startPos);
            const endPoint = new THREE.Vector3();
            ray.at(100, endPoint);
            points.push(endPoint);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            setTimeout(() => scene.remove(line), 150);
        }

        function dieAndRespawn() {
            if(isGod) return; 
            playerMesh.position.set(0, 10, 0); 
            velocityY = 0;
            addChatMessage("COMBATE", "VOC√ä MORREU!");
        }

        // --- NETWORKING ---
        function startMesh() {
            let room = document.getElementById('room-input').value.trim().toLowerCase();
            if(!room) return;
            const fullRoomID = room.startsWith(PREFIX) ? room : PREFIX + room;
            document.getElementById('server-menu').classList.remove('open');
            saveRecent(room);
            tryToBecomeHost(fullRoomID, room);
        }

        function tryToBecomeHost(id, roomNameDisplay) {
            peer = new Peer(id);
            peer.on('open', (myPeerId) => {
                myID = myPeerId; isHost = true;
                updatePlayerList();
            });
            peer.on('error', (err) => {
                if(err.type === 'unavailable-id') { peer.destroy(); becomeClient(id, roomNameDisplay); }
            });
            peer.on('connection', setupConn);
        }

        function becomeClient(hostId, roomNameDisplay) {
            myID = hostId + "-player-" + Math.floor(Math.random()*9999);
            peer = new Peer(myID);
            peer.on('open', () => {
                isHost = false;
                setupConn(peer.connect(hostId));
            });
            peer.on('connection', setupConn); 
        }

        function setupConn(conn) {
            conn.on('open', () => {
                connections[conn.peer] = conn;
                conn.send({ type: 'hello', nick: myNick, x: 0, y: 0.5, z: 0, senderId: myID, scale: isGiant?5:1, color: myColor, skin: mySkin });
                updatePlayerList();
            });
            conn.on('data', data => handleData(data, conn.peer));
            conn.on('close', () => { removePlayer(conn.peer); updatePlayerList(); });
        }

        function handleData(data, senderPeerId) {
            if(isHost) {
                data.senderId = data.senderId || senderPeerId; 
                broadcast(data, senderPeerId);
            }
            if(data.type === 'damage') {
                if(data.targetId === myID || (isHost && data.targetId === peer.id)) {
                    dieAndRespawn();
                }
            }

            if(data.senderId === myID) return;

            if(data.type === 'hello' || data.type === 'move') {
                updateRemote(data.senderId, data);
                if(data.type === 'hello') updatePlayerList();
            }
            if(data.type === 'chat') addChatMessage(data.nick, data.text);
            if(data.type === 'kick-all') location.reload();
            if(data.type === 'admin-cmd') {
                const me = myNick.replace("üëë ", "");
                if(data.target === me) {
                    if(data.cmd === 'ban-temp') { localStorage.setItem('nexus_temp_ban', Date.now() + (300000)); location.reload(); }
                    if(data.cmd === 'ban-perm') { localStorage.setItem('nexus_perm_ban', 'true'); location.reload(); }
                }
            }
        }

        function broadcast(data, ignoreId) {
            for(let id in connections) {
                if(connections[id].open && id !== ignoreId) connections[id].send(data);
            }
        }

        function updatePlayerList() {
            const listEl = document.getElementById('player-list-content');
            let html = `<div class="p-item" style="color:#00ff00">> ${myNick} (Voc√™)</div>`;
            for(let id in remotePlayers) {
                html += `<div class="p-item">> ${remotePlayers[id].nick}</div>`;
            }
            listEl.innerHTML = html;
        }

        function sendChat() {
            const input = document.getElementById('chat-input');
            if(!input.value.trim()) return;
            const msg = { type: 'chat', text: input.value, nick: myNick, senderId: myID };
            addChatMessage(myNick, input.value);
            if (isHost) broadcast(msg, null);
            else for(let id in connections) connections[id].send(msg);
            input.value = "";
        }

        function addChatMessage(nick, text) {
            const box = document.getElementById('chat-messages');
            const div = document.createElement('div');
            div.className = 'chat-line';
            div.innerHTML = `<span class="chat-nick">${nick}:</span><span>${text}</span>`;
            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
        }

        // --- CRIA√á√ÉO DE OBJETOS ---

        function generateFaceTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFE0BD'; 
            ctx.fillRect(0,0,64,64);
            
            ctx.fillStyle = 'white';
            ctx.fillRect(10, 20, 15, 10);
            ctx.fillRect(39, 20, 15, 10);
            ctx.fillStyle = 'black';
            ctx.fillRect(15, 22, 5, 5);
            ctx.fillRect(44, 22, 5, 5);

            ctx.fillStyle = '#aa5555';
            ctx.fillRect(20, 45, 24, 5);

            return new THREE.CanvasTexture(canvas);
        }

        function createHumanoid(color, skinType) {
            const group = new THREE.Group();

            let torsoColor = color;
            if(skinType === 'suit') torsoColor = 0x000044;
            if(skinType === 'military') torsoColor = 0x4b5320;
            if(skinType === 'neon') torsoColor = 0x00ff00;
            if(skinType === 'casual') torsoColor = 0x111111;

            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 0.4), new THREE.MeshPhongMaterial({ color: torsoColor }));
            torso.position.y = 0.35;
            group.add(torso);

            const headMat = new THREE.MeshBasicMaterial({ map: generateFaceTexture() });
            const skinMat = new THREE.MeshPhongMaterial({color: 0xFFE0BD});
            const headMaterials = [skinMat, skinMat, skinMat, skinMat, headMat, skinMat];

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), headMaterials);
            head.position.y = 0.9;
            group.add(head);

            const limbMat = new THREE.MeshPhongMaterial({color: skinType === 'neon' ? 0x000000 : 0x222222});
            const limbGeo = new THREE.BoxGeometry(0.2, 0.7, 0.2);

            const leftArm = new THREE.Mesh(limbGeo, new THREE.MeshPhongMaterial({color: color}));
            leftArm.position.set(-0.45, 0.5, 0);
            group.add(leftArm);

            const rightArm = new THREE.Mesh(limbGeo, new THREE.MeshPhongMaterial({color: color}));
            rightArm.position.set(0.45, 0.5, 0);
            group.add(rightArm);

            const leftLeg = new THREE.Mesh(limbGeo, limbMat);
            leftLeg.position.set(-0.2, -0.3, 0);
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(limbGeo, limbMat);
            rightLeg.position.set(0.2, -0.3, 0);
            group.add(rightLeg);

            group.userData = { leftArm, rightArm, leftLeg, rightLeg, head };

            return group;
        }

        function createSofa() {
            const sofaGroup = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({color: 0x8B4513}); 
            
            const seat = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 1.5), mat);
            seat.position.y = 0.25;
            
            const back = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 0.3), mat);
            back.position.set(0, 0.75, -0.6);

            const arm1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 1.5), mat);
            arm1.position.set(-1.3, 0.5, 0);
            const arm2 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 1.5), mat);
            arm2.position.set(1.3, 0.5, 0);

            sofaGroup.add(seat, back, arm1, arm2);
            return sofaGroup;
        }

        function createSign(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color || '#aa0000';
            ctx.fillRect(0,0,512,128);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 64);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            return new THREE.Mesh(new THREE.PlaneGeometry(10, 2.5), mat);
        }

        function createWeaponMesh(type) {
            const group = new THREE.Group();
            if(type === 'sword') {
                const handle = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.4, 0.05), new THREE.MeshLambertMaterial({color:0x8B4513}));
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.05, 1.2, 0.02), new THREE.MeshStandardMaterial({color:0xcccccc}));
                blade.position.y = 0.8;
                const guard = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.05), new THREE.MeshLambertMaterial({color:0xFFD700}));
                guard.position.y = 0.2;
                group.add(handle, blade, guard);
                group.rotation.x = Math.PI / 2; 
                group.position.set(0.6, 0.5, -0.4); 
            } else if (type === 'gun') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, 0.5), new THREE.MeshLambertMaterial({color:0x111111}));
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.5), new THREE.MeshLambertMaterial({color:0x333333}));
                barrel.rotation.x = Math.PI / 2;
                barrel.position.z = -0.3;
                barrel.position.y = 0.05;
                const handle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.1), new THREE.MeshLambertMaterial({color:0x000000}));
                handle.position.y = -0.15;
                handle.rotation.x = 0.3;
                group.add(body, barrel, handle);
                group.position.set(0.6, 0.5, -0.4);
            }
            return group;
        }

        function initEngine() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            renderer.domElement.addEventListener('pointerdown', (e) => {
                if(e.target.className.includes('btn-game')) return;
                attemptAttack();
            });

            document.body.appendChild(renderer.domElement);
            
            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 0.8 );
            hemiLight.position.set( 0, 20, 0 );
            scene.add( hemiLight );
            const dirLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
            dirLight.position.set( -10, 20, 10 );
            dirLight.castShadow = true;
            scene.add( dirLight );

            // CH√ÉO
            const planeGeo = new THREE.PlaneGeometry(150, 150);
            const planeMat = new THREE.MeshStandardMaterial({ color: 0x228B22 }); 
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);
            scene.add(new THREE.GridHelper(150, 75, 0x000000, 0x004400));
            collidableObjects.push(plane);

            // PAREDES
            const wallMat = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.1, transparent: true, side: THREE.DoubleSide });
            const w1 = new THREE.Mesh(new THREE.BoxGeometry(150, 50, 1), wallMat); w1.position.set(0, 25, -75); scene.add(w1);
            const w2 = new THREE.Mesh(new THREE.BoxGeometry(150, 50, 1), wallMat); w2.position.set(0, 25, 75); scene.add(w2);
            const w3 = new THREE.Mesh(new THREE.BoxGeometry(1, 50, 150), wallMat); w3.position.set(75, 25, 0); scene.add(w3);
            const w4 = new THREE.Mesh(new THREE.BoxGeometry(1, 50, 150), wallMat); w4.position.set(-75, 25, 0); scene.add(w4);
            collidableObjects.push(w1, w2, w3, w4);

            // --- ARENA PVP ---
            const arenaGeo = new THREE.BoxGeometry(20, 0.2, 20);
            const arenaMat = new THREE.MeshStandardMaterial({ color: 0x880000 }); 
            const arena = new THREE.Mesh(arenaGeo, arenaMat);
            arena.position.set(-40, 0.1, 0); 
            arena.receiveShadow = true;
            scene.add(arena);
            const signArena = createSign("ARENA PVP (AUTO-EQUIP)", "#000");
            signArena.position.set(-40, 4, -10);
            scene.add(signArena);

            // --- SOF√ÅS ---
            for(let i=0; i<5; i++) {
                const sofa = createSofa();
                sofa.position.set(Math.random() * 40 - 20, 0, Math.random() * 40 + 10);
                sofa.rotation.y = Math.random() * Math.PI;
                scene.add(sofa);
                collidableObjects.push(sofa.children[0]); 
            }

            // --- PARKOUR ---
            const boxGeo = new THREE.BoxGeometry(2, 0.5, 2);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            for(let i=0; i<10; i++) {
                const p = new THREE.Mesh(boxGeo, boxMat);
                p.position.set(10 + (i*3), 2 + (i*1.5), -10 + (Math.random()*5));
                scene.add(p);
                collidableObjects.push(p);
            }

            // --- ESCADA E SALA FINAL ---
            const stepGeo = new THREE.BoxGeometry(3, 0.5, 1);
            const stepMat = new THREE.MeshStandardMaterial({ color: 0xFF00FF });
            let lastX = 0, lastY = 0, lastZ = 0;
            for(let i=0; i<80; i++) {
                const step = new THREE.Mesh(stepGeo, stepMat);
                const angle = i * 0.3; 
                const radius = 8;
                lastX = Math.cos(angle) * radius + 20;
                lastY = 1 + (i * 0.8);
                lastZ = Math.sin(angle) * radius + 20;
                step.position.set(lastX, lastY, lastZ);
                step.rotation.y = -angle;
                scene.add(step);
                collidableObjects.push(step);
            }
            const finalRoomY = lastY + 0.5;
            const floorFinal = new THREE.Mesh(new THREE.BoxGeometry(15, 1, 15), new THREE.MeshStandardMaterial({color: 0xeeeeee}));
            floorFinal.position.set(lastX, finalRoomY, lastZ);
            scene.add(floorFinal);
            collidableObjects.push(floorFinal);

            // PLAYER
            playerMesh = createHumanoid(myColor, mySkin);
            playerMesh.position.y = 0.5;
            playerMesh.castShadow = true;
            playerLimbs = playerMesh.userData;

            mySword = createWeaponMesh('sword');
            myGun = createWeaponMesh('gun');
            mySword.visible = false;
            myGun.visible = false;
            
            if(playerLimbs.rightArm) {
                playerLimbs.rightArm.add(mySword);
                playerLimbs.rightArm.add(myGun);
                mySword.position.set(0, -0.4, 0.2); 
                mySword.rotation.set(Math.PI/2, 0, 0);
                myGun.position.set(0, -0.4, 0.2);
                myGun.rotation.set(0, Math.PI/2, 0); 
            }

            scene.add(playerMesh);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = false;
            controls.minDistance = 3;
            controls.maxDistance = 20;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; 
            
            animate();
        }

        function jump() { 
            if(isFlying) { velocityY = 0.5; return; }
            if(isGrounded) { velocityY = 0.35; isGrounded = false; } 
        }

        function checkCollisions() {
            if(playerMesh.position.x > 74) playerMesh.position.x = 74;
            if(playerMesh.position.x < -74) playerMesh.position.x = -74;
            if(playerMesh.position.z > 74) playerMesh.position.z = 74;
            if(playerMesh.position.z < -74) playerMesh.position.z = -74;

            const rayOrigin = playerMesh.position.clone();
            rayOrigin.y += 0.5; 
            raycaster.set(rayOrigin, new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObjects(collidableObjects, true);
            
            if (intersects.length > 0) {
                 const dist = intersects[0].distance;
                 if(dist < 0.6 + Math.abs(velocityY)) {
                     if(velocityY <= 0) {
                         isGrounded = true;
                         velocityY = 0;
                         playerMesh.position.y = intersects[0].point.y; 
                     }
                 } else { isGrounded = false; }
            } else { isGrounded = false; }
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!playerMesh) return;

            let moved = false;
            let forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0; 
            forward.normalize();
            let right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize(); 

            if(keys.w) { playerMesh.position.add(forward.clone().multiplyScalar(moveSpeed)); moved = true; }
            if(keys.s) { playerMesh.position.add(forward.clone().multiplyScalar(-moveSpeed)); moved = true; }
            if(keys.a) { playerMesh.position.add(right.clone().multiplyScalar(-moveSpeed)); moved = true; } 
            if(keys.d) { playerMesh.position.add(right.clone().multiplyScalar(moveSpeed)); moved = true; } 

            if(moved) {
                playerMesh.rotation.y = Math.atan2(forward.x, forward.z); 
                if(keys.a) playerMesh.rotation.y += Math.PI/2;
                if(keys.d) playerMesh.rotation.y -= Math.PI/2;
                if(keys.s) playerMesh.rotation.y += Math.PI;

                const time = Date.now() * 0.01;
                if(playerLimbs.leftArm) {
                    playerLimbs.leftArm.rotation.x = Math.sin(time) * 0.5;
                    playerLimbs.rightArm.rotation.x = Math.sin(time + Math.PI) * 0.5;
                    playerLimbs.leftLeg.rotation.x = Math.sin(time + Math.PI) * 0.5;
                    playerLimbs.rightLeg.rotation.x = Math.sin(time) * 0.5;
                }
            } else {
                if(playerLimbs.leftArm) {
                    playerLimbs.leftArm.rotation.x = 0;
                    playerLimbs.rightArm.rotation.x = 0;
                    playerLimbs.leftLeg.rotation.x = 0;
                    playerLimbs.rightLeg.rotation.x = 0;
                }
            }

            if(!isFlying) {
                velocityY -= 0.015; 
                playerMesh.position.y += velocityY;
                checkCollisions(); 
                if(playerMesh.position.y < -20) dieAndRespawn();
            } else {
                playerMesh.position.y += velocityY;
                velocityY *= 0.9; 
            }

            controls.target.copy(playerMesh.position);
            controls.update();

            const distArena = playerMesh.position.distanceTo(new THREE.Vector3(-40, 0, 0));
            if(distArena < 10) {
                   if(!inArena) { inArena = true; updateWeaponStatus(); }
            } else {
                   if(inArena) { inArena = false; updateWeaponStatus(); }
            }

            if(moved || !isGrounded || isFlying || inArena || hasGun) {
                const wpState = hasGun ? 2 : (inArena ? 1 : 0);
                const moveData = { 
                    type:'move', x:playerMesh.position.x, y:playerMesh.position.y, z:playerMesh.position.z, 
                    ry: playerMesh.rotation.y, nick: myNick, senderId: myID,
                    scale: isGiant ? 5 : 1, color: myColor, skin: mySkin, wp: wpState 
                };
                if(isHost) broadcast(moveData, null); 
                else for(let id in connections) connections[id].send(moveData);
            }

            for(let id in remotePlayers) {
                const p = remotePlayers[id];
                p.mesh.position.lerp(p.targetPos, 0.2);
                if(p.targetRot !== undefined) p.mesh.rotation.y = p.targetRot; 
                
                const speed = p.mesh.position.distanceTo(p.targetPos);
                if(speed > 0.01) {
                    const rTime = Date.now() * 0.01;
                    if(p.limbs && p.limbs.leftArm) {
                        p.limbs.leftArm.rotation.x = Math.sin(rTime) * 0.5;
                        p.limbs.rightArm.rotation.x = Math.sin(rTime + Math.PI) * 0.5;
                        p.limbs.leftLeg.rotation.x = Math.sin(rTime + Math.PI) * 0.5;
                        p.limbs.rightLeg.rotation.x = Math.sin(rTime) * 0.5;
                    }
                }

                const tagOffset = p.mesh.scale.x * 2.0;
                const tempV = p.mesh.position.clone().add(new THREE.Vector3(0, tagOffset, 0)).project(camera);
                if(tempV.z < 1) {
                     p.tag.style.left = (tempV.x * .5 + .5) * window.innerWidth + 'px';
                     p.tag.style.top = (tempV.y * -.5 + .5) * window.innerHeight + 'px';
                     p.tag.style.display = 'block';
                } else { p.tag.style.display = 'none'; }
            }
            renderer.render(scene, camera);
        }

        function updateRemote(id, data) {
            if(!remotePlayers[id]) {
                const pColor = data.color || 0x00ffff;
                const pSkin = data.skin || "casual";
                const mesh = createHumanoid(pColor, pSkin);
                const rSword = createWeaponMesh('sword');
                const rGun = createWeaponMesh('gun');
                rSword.visible = false; rGun.visible = false;

                if(mesh.userData.rightArm) {
                    mesh.userData.rightArm.add(rSword);
                    mesh.userData.rightArm.add(rGun);
                    rSword.position.set(0, -0.4, 0.2); rSword.rotation.set(Math.PI/2, 0, 0);
                    rGun.position.set(0, -0.4, 0.2); rGun.rotation.set(0, Math.PI/2, 0);
                }

                mesh.castShadow = true;
                scene.add(mesh);
                const tag = document.createElement('div');
                tag.className = 'player-tag';
                tag.innerText = data.nick || "Player";
                document.body.appendChild(tag);
                
                remotePlayers[id] = { 
                    mesh, tag, targetPos: new THREE.Vector3(data.x, data.y, data.z),
                    targetRot: 0, nick: data.nick, sword: rSword, gun: rGun, limbs: mesh.userData
                };
            } else {
                remotePlayers[id].targetPos.set(data.x, data.y, data.z);
                if(data.ry !== undefined) remotePlayers[id].targetRot = data.ry;
                if(data.scale) remotePlayers[id].mesh.scale.set(data.scale, data.scale, data.scale);
                const p = remotePlayers[id];
                if(data.wp === 2) { p.sword.visible=false; p.gun.visible=true; }
                else if(data.wp === 1) { p.sword.visible=true; p.gun.visible=false; }
                else { p.sword.visible=false; p.gun.visible=false; }
            }
        }

        function removePlayer(id) {
            if(remotePlayers[id]) {
                scene.remove(remotePlayers[id].mesh);
                if(remotePlayers[id].tag) document.body.removeChild(remotePlayers[id].tag);
                delete remotePlayers[id];
                delete connections[id];
            }
        }

        function saveRecent(id) {
            let r = JSON.parse(localStorage.getItem('n_rooms') || "[]");
            if(!r.includes(id)) r.push(id);
            localStorage.setItem('n_rooms', JSON.stringify(r.slice(-5)));
            updateRecentUI();
        }

        function updateRecentUI() {
            const list = JSON.parse(localStorage.getItem('n_rooms') || "[]");
            document.getElementById('recent-list').innerHTML = list.map(id => `<div style="background:#222; padding:8px; margin-top:5px; font-size:10px; border:1px solid #333; cursor:pointer;" onclick="document.getElementById('room-input').value='${id}'; startMesh()">${id}</div>`).join('');
        }

        setupKeyboard();
    </script>
</body>
</html>
